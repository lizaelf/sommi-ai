import { Message, Conversation } from '@shared/schema';
import { ClientMessage, ClientConversation } from './types';
import { IDBMessage, IDBConversation } from './indexedDB';

// Convert IndexedDB message to client message format
export function adaptIDBMessageToMessage(message: IDBMessage): ClientMessage {
  return {
    id: message.id || 0,
    conversationId: message.conversationId,
    role: message.role,
    content: message.content,
    createdAt: message.createdAt
  };
}

// Convert message to IndexedDB format
export function adaptMessageToIDBMessage(message: Message | ClientMessage): IDBMessage {
  return {
    conversationId: message.conversationId,
    role: message.role,
    content: message.content,
    createdAt: message.createdAt instanceof Date ? message.createdAt : 
              (typeof message.createdAt === 'string' ? new Date(message.createdAt) : new Date())
  };
}

// Convert array of IndexedDB messages to client messages
export function adaptIDBMessagesToMessages(messages: IDBMessage[]): ClientMessage[] {
  // Ensure messages is an array before mapping
  if (!Array.isArray(messages)) {
    console.error('adaptIDBMessagesToMessages: messages is not an array', messages);
    return [];
  }
  return messages.map(adaptIDBMessageToMessage);
}

// Convert IndexedDB conversation to client conversation format
export function adaptIDBConversationToConversation(conversation: IDBConversation): ClientConversation {
  return {
    id: conversation.id || 0,
    userId: conversation.userId,
    title: conversation.title || 'Untitled Conversation',
    createdAt: conversation.createdAt,
    lastActivity: conversation.lastActivity || conversation.createdAt,
    messageCount: Array.isArray(conversation.messages) ? conversation.messages.length : 0
  };
}

// Convert array of IndexedDB conversations to client conversations
export function adaptIDBConversationsToConversations(conversations: IDBConversation[]): ClientConversation[] {
  // Ensure conversations is an array before mapping
  if (!Array.isArray(conversations)) {
    console.error('adaptIDBConversationsToConversations: conversations is not an array', conversations);
    return [];
  }
  return conversations.map(adaptIDBConversationToConversation);
}

// Convert client conversation to IndexedDB format
export function adaptConversationToIDBConversation(conversation: ClientConversation): IDBConversation {
  return {
    id: conversation.id,
    userId: conversation.userId,
    title: conversation.title,
    createdAt: conversation.createdAt,
    lastActivity: conversation.lastActivity || conversation.createdAt,
    messages: [] // Messages are stored separately in IDBConversation
  };
}

// Convert date objects to string for serialization
export function serializeDates(obj: any): any {
  if (obj === null || obj === undefined) {
    return obj;
  }
  
  if (obj instanceof Date) {
    return obj.toISOString();
  }
  
  if (Array.isArray(obj)) {
    return obj.map(serializeDates);
  }
  
  if (typeof obj === 'object') {
    const result: any = {};
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        result[key] = serializeDates(obj[key]);
      }
    }
    return result;
  }
  
  return obj;
}