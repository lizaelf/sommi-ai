// Add these to your browser console or create a debug component to test your audio setup

// 1. Test TTS API directly
const testTTSAPI = async (text = "This is a test audio message") => {
  try {
    console.log("ðŸ”§ Testing TTS API...");
    const response = await fetch("/api/text-to-speech", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text }),
    });
    
    console.log("ðŸ”§ TTS API Response:", {
      ok: response.ok,
      status: response.status,
      contentType: response.headers.get('content-type'),
      contentLength: response.headers.get('content-length')
    });
    
    if (response.ok) {
      const audioBuffer = await response.arrayBuffer();
      console.log("ðŸ”§ Audio buffer size:", audioBuffer.byteLength, "bytes");
      
      // Test direct playback
      const audioBlob = new Blob([audioBuffer], { type: "audio/mpeg" });
      const audioUrl = URL.createObjectURL(audioBlob);
      const testAudio = new Audio(audioUrl);
      
      console.log("ðŸ”§ Attempting to play test audio...");
      
      testAudio.oncanplaythrough = async () => {
        try {
          await testAudio.play();
          console.log("âœ… Direct TTS test successful!");
        } catch (e) {
          console.error("âŒ Direct TTS test failed:", e);
        } finally {
          URL.revokeObjectURL(audioUrl);
        }
      };
      
      testAudio.onerror = (e) => {
        console.error("âŒ Audio error:", e);
        URL.revokeObjectURL(audioUrl);
      };
      
      testAudio.load();
      return true;
    } else {
      const errorText = await response.text();
      console.error("âŒ TTS API failed:", errorText);
      return false;
    }
  } catch (error) {
    console.error("âŒ TTS API test failed:", error);
    return false;
  }
};

// 2. Check wine responses data structure
const checkWineResponses = (wineKey = "wine_1") => {
  try {
    // You'll need to import this or access it from your app
    // import wineResponses from "@/../../shared/wineResponses.json";
    
    console.log("ðŸ”§ Checking wine responses for:", wineKey);
    
    // Replace this with actual import
    const wineResponses = (window as any).wineResponses || {};
    
    const wineData = wineResponses[wineKey];
    if (!wineData) {
      console.error("âŒ No wine data found for:", wineKey);
      console.log("Available wine keys:", Object.keys(wineResponses));
      return false;
    }
    
    const responses = wineData.responses;
    if (!responses) {
      console.error("âŒ No responses found in wine data");
      console.log("Wine data structure:", wineData);
      return false;
    }
    
    console.log("âœ… Wine responses found:");
    Object.keys(responses).forEach(key => {
      const response = responses[key];
      console.log(`  ${key}: ${typeof response} (${response?.length || 0} chars)`);
    });
    
    return true;
  } catch (error) {
    console.error("âŒ Error checking wine responses:", error);
    return false;
  }
};

// 3. Test audio cache and pre-generation
const testAudioCache = () => {
  const audioCache = (window as any).suggestionAudioCache || {};
  console.log("ðŸ”§ Audio cache status:");
  console.log("Cache size:", Object.keys(audioCache).length);
  console.log("Cached URLs:", Object.keys(audioCache));
  
  Object.entries(audioCache).forEach(([key, url]) => {
    console.log(`  ${key}: ${typeof url}`);
    
    // Test if the URL is still valid
    if (typeof url === 'string') {
      const testAudio = new Audio(url as string);
      testAudio.oncanplaythrough = () => {
        console.log(`âœ… ${key}: Audio URL is valid`);
      };
      testAudio.onerror = () => {
        console.log(`âŒ ${key}: Audio URL is invalid`);
      };
      testAudio.load();
    }
  });
};

// 4. Test browser audio capabilities
const testBrowserAudio = async () => {
  console.log("ðŸ”§ Testing browser audio capabilities...");
  
  // Check basic audio support
  const audio = new Audio();
  const canPlayMP3 = audio.canPlayType('audio/mpeg');
  const canPlayMP4 = audio.canPlayType('audio/mp4');
  const canPlayWAV = audio.canPlayType('audio/wav');
  
  console.log("Audio format support:", {
    mp3: canPlayMP3,
    mp4: canPlayMP4,
    wav: canPlayWAV
  });
  
  // Check AudioContext
  const AudioContext = window.AudioContext || (window as any).webkitAudioContext;
  const hasAudioContext = !!AudioContext;
  console.log("AudioContext support:", hasAudioContext);
  
  // Test autoplay capability
  try {
    const silentAudio = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA');
    await silentAudio.play();
    console.log("âœ… Audio autoplay is allowed");
    return true;
  } catch (error) {
    console.log("âŒ Audio autoplay is blocked:", error);
    console.log("ðŸ’¡ User interaction will be required for audio playback");
    return false;
  }
};

// 5. Clear all audio state (useful for debugging)
const clearAllAudioState = () => {
  console.log("ðŸ§¹ Clearing all audio state...");
  
  // Clear audio cache
  const audioCache = (window as any).suggestionAudioCache || {};
  Object.values(audioCache).forEach((url: unknown) => {
    if (typeof url === 'string') {
      URL.revokeObjectURL(url);
    }
  });
  (window as any).suggestionAudioCache = {};
  
  // Stop current audio
  if ((window as any).currentOpenAIAudio) {
    try {
      (window as any).currentOpenAIAudio.pause();
      (window as any).currentOpenAIAudio = null;
    } catch (e) {
      console.warn("Error stopping audio:", e);
    }
  }
  
  // Clear audio lock
  (window as any).audioLock = false;
  
  console.log("âœ… Audio state cleared");
};

// 6. Run comprehensive audio test
const runFullAudioTest = async () => {
  console.log("ðŸ”§ Running comprehensive audio test...");
  
  const results = {
    browserSupport: await testBrowserAudio(),
    ttsAPI: await testTTSAPI(),
    wineData: checkWineResponses(),
    audioCache: testAudioCache()
  };
  
  console.log("ðŸ”§ Test Results Summary:", results);
  
  const allPassed = Object.values(results).every(Boolean);
  console.log(allPassed ? "âœ… All tests passed!" : "âŒ Some tests failed");
  
  return results;
};

// 7. Debug specific suggestion pill
const debugSuggestionPill = (wineKey = "wine_1", prompt = "Tell me about this wine") => {
  console.log("ðŸ”§ Debugging suggestion pill...");
  
  const suggestionId = prompt.toLowerCase().replace(/[^a-z0-9]+/g, "_");
  const cacheKey = `${wineKey}:${suggestionId}:audio`;
  
  console.log("Generated IDs:", {
    wineKey,
    prompt,
    suggestionId,
    cacheKey
  });
  
  // Check if audio exists in cache
  const audioCache = (window as any).suggestionAudioCache || {};
  const hasAudio = !!audioCache[cacheKey];
  
  console.log("Cache status:", {
    hasAudio,
    cacheKeys: Object.keys(audioCache)
  });
  
  // Check wine response data
  try {
    const wineResponses = (window as any).wineResponses || {};
    const wineData = wineResponses[wineKey];
    const responseText = wineData?.responses?.[suggestionId];
    
    console.log("Wine data:", {
      hasWineData: !!wineData,
      hasResponse: !!responseText,
      responseLength: responseText?.length || 0
    });
  } catch (error) {
    console.error("Error checking wine data:", error);
  }
};

// Export functions for use
(window as any).audioDebugUtils = {
  testTTSAPI,
  checkWineResponses,
  testAudioCache,
  testBrowserAudio,
  clearAllAudioState,
  runFullAudioTest,
  debugSuggestionPill
};

console.log("ðŸ”§ Audio debug utilities loaded! Available functions:");
console.log("- testTTSAPI(text?)");
console.log("- checkWineResponses(wineKey?)");
console.log("- testAudioCache()");
console.log("- testBrowserAudio()");
console.log("- clearAllAudioState()");
console.log("- runFullAudioTest()");
console.log("- debugSuggestionPill(wineKey?, prompt?)");
console.log("");
console.log("Quick start: Run audioDebugUtils.runFullAudioTest() to test everything!");