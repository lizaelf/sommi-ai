// WineScanner.js - IndexedDB storage implementation

class WineScanner {
  constructor() {
    this.db = null;
    this.dbName = 'wineScannerDB';
    this.dbVersion = 1;
    this.initDB();
  }

  // Initialize the database
  initDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // Create object store for wine bottles if it doesn't exist
        if (!db.objectStoreNames.contains('wines')) {
          const wineStore = db.createObjectStore('wines', { keyPath: 'id' });
          wineStore.createIndex('scanDate', 'scanDate', { unique: false });
          wineStore.createIndex('wineType', 'wineType', { unique: false });
        }
        
        // Create object store for chat history
        if (!db.objectStoreNames.contains('chatHistory')) {
          const chatStore = db.createObjectStore('chatHistory', { keyPath: 'wineId' });
        }
      };
      
      request.onsuccess = (event) => {
        this.db = event.target.result;
        console.log('Database initialized successfully');
        resolve(this.db);
      };
      
      request.onerror = (event) => {
        console.error('Error initializing database:', event.target.error);
        reject(event.target.error);
      };
    });
  }

  // Add a new wine bottle from QR code scan
  async addWine(wineData) {
    // Generate a unique ID if not provided by QR
    const id = wineData.id || `wine_${Date.now()}`;
    
    const wine = {
      id,
      name: wineData.name,
      winery: wineData.winery,
      year: wineData.year,
      wineType: wineData.wineType || 'unknown',
      region: wineData.region,
      notes: wineData.notes || '',
      scanDate: new Date(),
      userRating: null,
      // Save image URL or data if available
      imageUrl: wineData.imageUrl || null
    };
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['wines'], 'readwrite');
      const store = transaction.objectStore('wines');
      
      const request = store.put(wine);
      
      request.onsuccess = () => {
        resolve(wine);
      };
      
      request.onerror = (event) => {
        console.error('Error adding wine:', event.target.error);
        reject(event.target.error);
      };
    });
  }

  // Get all scanned wines
  async getAllWines() {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['wines'], 'readonly');
      const store = transaction.objectStore('wines');
      const request = store.getAll();
      
      request.onsuccess = (event) => {
        resolve(event.target.result);
      };
      
      request.onerror = (event) => {
        console.error('Error getting wines:', event.target.error);
        reject(event.target.error);
      };
    });
  }

  // Get a specific wine by ID
  async getWine(id) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['wines'], 'readonly');
      const store = transaction.objectStore('wines');
      const request = store.get(id);
      
      request.onsuccess = (event) => {
        resolve(event.target.result);
      };
      
      request.onerror = (event) => {
        console.error('Error getting wine:', event.target.error);
        reject(event.target.error);
      };
    });
  }

  // Update wine details (e.g., after adding user rating)
  async updateWine(id, updatedData) {
    return new Promise(async (resolve, reject) => {
      try {
        // First get the existing wine
        const wine = await this.getWine(id);
        if (!wine) {
          reject(new Error('Wine not found'));
          return;
        }
        
        // Update with new data
        const updatedWine = { ...wine, ...updatedData };
        
        const transaction = this.db.transaction(['wines'], 'readwrite');
        const store = transaction.objectStore('wines');
        const request = store.put(updatedWine);
        
        request.onsuccess = () => {
          resolve(updatedWine);
        };
        
        request.onerror = (event) => {
          reject(event.target.error);
        };
      } catch (error) {
        reject(error);
      }
    });
  }

  // Delete a wine from the database
  async deleteWine(id) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['wines', 'chatHistory'], 'readwrite');
      const wineStore = transaction.objectStore('wines');
      const chatStore = transaction.objectStore('chatHistory');
      
      // Delete the wine
      const wineRequest = wineStore.delete(id);
      
      wineRequest.onsuccess = () => {
        // Also delete associated chat history
        const chatRequest = chatStore.delete(id);
        
        chatRequest.onsuccess = () => {
          resolve(true);
        };
        
        chatRequest.onerror = (event) => {
          console.error('Error deleting chat history:', event.target.error);
          // Still resolve as success if wine was deleted
          resolve(true);
        };
      };
      
      wineRequest.onerror = (event) => {
        console.error('Error deleting wine:', event.target.error);
        reject(event.target.error);
      };
    });
  }

  // Save chat messages for a specific wine
  async saveChatHistory(wineId, messages) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['chatHistory'], 'readwrite');
      const store = transaction.objectStore('chatHistory');
      
      const request = store.put({ wineId, messages });
      
      request.onsuccess = () => {
        resolve(true);
      };
      
      request.onerror = (event) => {
        console.error('Error saving chat history:', event.target.error);
        reject(event.target.error);
      };
    });
  }

  // Get chat history for a specific wine
  async getChatHistory(wineId) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['chatHistory'], 'readonly');
      const store = transaction.objectStore('chatHistory');
      const request = store.get(wineId);
      
      request.onsuccess = (event) => {
        // Return the messages array or an empty array if none exists
        const result = event.target.result;
        resolve(result ? result.messages : []);
      };
      
      request.onerror = (event) => {
        console.error('Error getting chat history:', event.target.error);
        reject(event.target.error);
      };
    });
  }

  // Add a new message to chat history
  async addChatMessage(wineId, message) {
    try {
      // Get existing messages
      const existingMessages = await this.getChatHistory(wineId);
      
      // Add new message
      const updatedMessages = [...existingMessages, {
        id: Date.now(),
        text: message.text,
        sender: message.sender, // 'user' or 'ai'
        timestamp: new Date()
      }];
      
      // Save updated chat history
      await this.saveChatHistory(wineId, updatedMessages);
      return updatedMessages;
    } catch (error) {
      console.error('Error adding chat message:', error);
      throw error;
    }
  }

  // Export all user data (for backup or sharing)
  async exportData() {
    try {
      const wines = await this.getAllWines();
      
      // Get chat history for each wine
      const chatPromises = wines.map(async (wine) => {
        const messages = await this.getChatHistory(wine.id);
        return { wineId: wine.id, messages };
      });
      
      const chats = await Promise.all(chatPromises);
      
      return {
        wines,
        chatHistory: chats,
        exportDate: new Date()
      };
    } catch (error) {
      console.error('Error exporting data:', error);
      throw error;
    }
  }

  // Import data (from backup)
  async importData(data) {
    if (!data || !data.wines) {
      throw new Error('Invalid data format');
    }
    
    try {
      // Import wines
      const winePromises = data.wines.map(wine => this.addWine(wine));
      await Promise.all(winePromises);
      
      // Import chat histories
      if (data.chatHistory) {
        const chatPromises = data.chatHistory.map(chat => 
          this.saveChatHistory(chat.wineId, chat.messages)
        );
        await Promise.all(chatPromises);
      }
      
      return true;
    } catch (error) {
      console.error('Error importing data:', error);
      throw error;
    }
  }
}

// Usage example:
async function initializeWineScanner() {
  const scanner = new WineScanner();
  
  // Wait for DB to initialize
  await scanner.initDB();
  
  // Now you can use the scanner
  return scanner;
}

// Create and expose the scanner instance
let wineScanner;
window.addEventListener('DOMContentLoaded', async () => {
  wineScanner = await initializeWineScanner();
  console.log('Wine Scanner initialized and ready');
});