// public/app.js - Main frontend code

document.addEventListener('DOMContentLoaded', () => {
  // DOM Elements
  const chatMessages = document.getElementById('chat-messages');
  const textInput = document.getElementById('text-input');
  const sendButton = document.getElementById('send-button');
  const voiceButton = document.getElementById('voice-button');
  const statusIndicator = document.getElementById('status-indicator');
  const scanButton = document.getElementById('scan-button');
  const wineCollection = document.getElementById('wineCollection');
  
  // Initialize WineStorage
  const wineStorage = new WineStorage();
  wineStorage.initDB().then(() => {
    loadWines();
  });

  // Chat history array for context
  let chatHistory = [];
  
  // Speech recognition setup
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  const recognition = new SpeechRecognition();
  recognition.continuous = false;
  recognition.lang = 'en-US';
  recognition.interimResults = false;
  
  // Speech synthesis setup
  const synth = window.speechSynthesis;
  
  // Variable to track if we should use OpenAI's TTS or browser's
  const useOpenAIVoice = true; // Set to false to use browser's built-in TTS

  // Load wines from storage
  async function loadWines() {
    try {
      const wines = await wineStorage.getAllWines();
      
      if (wines.length === 0) {
        wineCollection.innerHTML = `
          <div class="empty-wines">
            <p>No wines in your collection yet. Scan a wine to get started!</p>
          </div>
        `;
        return;
      }
      
      wineCollection.innerHTML = '';
      wines.forEach(wine => {
        const wineCard = document.createElement('div');
        wineCard.className = 'wine-card';
        wineCard.dataset.id = wine.id;
        
        wineCard.innerHTML = `
          <div class="wine-image" style="background-color: ${getRandomWineColor(wine.wineType)}"></div>
          <div class="wine-info">
            <div class="wine-name">${wine.name}</div>
            <div class="wine-details">${wine.winery}, ${wine.year}</div>
          </div>
        `;
        
        wineCard.addEventListener('click', () => {
          selectWine(wine);
        });
        
        wineCollection.appendChild(wineCard);
      });
    } catch (error) {
      console.error('Error loading wines:', error);
    }
  }
  
  // Get a color based on wine type
  function getRandomWineColor(wineType) {
    if (!wineType) return '#A4243B';
    
    switch(wineType.toLowerCase()) {
      case 'red': return `#${Math.floor(Math.random() * 56 + 132).toString(16)}${Math.floor(Math.random() * 20 + 20).toString(16)}${Math.floor(Math.random() * 20 + 20).toString(16)}`;
      case 'white': return `#${Math.floor(Math.random() * 20 + 235).toString(16)}${Math.floor(Math.random() * 20 + 235).toString(16)}${Math.floor(Math.random() * 56 + 182).toString(16)}`;
      case 'rosé': return `#${Math.floor(Math.random() * 20 + 235).toString(16)}${Math.floor(Math.random() * 56 + 182).toString(16)}${Math.floor(Math.random() * 56 + 182).toString(16)}`;
      case 'sparkling': return `#${Math.floor(Math.random() * 20 + 235).toString(16)}${Math.floor(Math.random() * 20 + 225).toString(16)}${Math.floor(Math.random() * 20 + 165).toString(16)}`;
      default: return '#D8973C';
    }
  }
  
  // Select wine and ask AI about it
  function selectWine(wine) {
    addMessage(`Tell me about this ${wine.name} from ${wine.winery}, ${wine.year}`, 'user');
    sendToAI(`Tell me about this ${wine.name} from ${wine.winery}, ${wine.year}`);
  }
  
  // Send message when button is clicked
  sendButton.addEventListener('click', () => {
    const message = textInput.value.trim();
    if (message) {
      addMessage(message, 'user');
      sendToAI(message);
      textInput.value = '';
    }
  });
  
  // Send message when Enter key is pressed
  textInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      const message = textInput.value.trim();
      if (message) {
        addMessage(message, 'user');
        sendToAI(message);
        textInput.value = '';
      }
    }
  });
  
  // Voice button click handler
  voiceButton.addEventListener('click', toggleListening);
  
  // Toggle speech recognition
  function toggleListening() {
    if (voiceButton.classList.contains('listening')) {
      // Stop listening
      recognition.stop();
      voiceButton.classList.remove('listening');
      updateStatus('');
    } else {
      // Start listening
      recognition.start();
      voiceButton.classList.add('listening');
      updateStatus('Listening...');
    }
  }
  
  // Speech recognition event handlers
  recognition.onresult = (event) => {
    const transcript = event.results[0][0].transcript;
    textInput.value = transcript;
    
    // Stop recognition
    recognition.stop();
    voiceButton.classList.remove('listening');
    updateStatus('Processing...');
    
    // Send message
    addMessage(transcript, 'user');
    sendToAI(transcript);
    textInput.value = '';
  };
  
  recognition.onend = () => {
    voiceButton.classList.remove('listening');
    updateStatus('');
  };
  
  recognition.onerror = (event) => {
    console.error('Speech recognition error', event.error);
    voiceButton.classList.remove('listening');
    updateStatus('Error: ' + event.error);
    setTimeout(() => updateStatus(''), 3000);
  };
  
  // Update status indicator
  function updateStatus(message) {
    statusIndicator.textContent = message;
    if (message) {
      statusIndicator.classList.add('active');
    } else {
      statusIndicator.classList.remove('active');
    }
  }
  
  // Add a message to the chat
  function addMessage(content, sender) {
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender}-message`;
    
    const messageContent = document.createElement('div');
    messageContent.className = 'message-content';
    messageContent.textContent = content;
    
    messageDiv.appendChild(messageContent);
    chatMessages.appendChild(messageDiv);
    
    // Scroll to bottom
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Save to chat history
    if (sender === 'user') {
      chatHistory.push({ role: "user", content });
    } else {
      chatHistory.push({ role: "assistant", content });
    }
    
    // Keep chat history at a reasonable size
    if (chatHistory.length > 20) {
      chatHistory = chatHistory.slice(chatHistory.length - 20);
    }
  }
  
  // Send message to AI
  async function sendToAI(message) {
    try {
      updateStatus('AI is thinking...');
      
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          message,
          history: chatHistory
        })
      });
      
      if (!response.ok) {
        throw new Error('Network response was not ok');
      }
      
      const data = await response.json();
      updateStatus('');
      
      // Add AI response to chat
      addMessage(data.response, 'ai');
      
      // Speak the response
      speakResponse(data.response);
      
    } catch (error) {
      console.error('Error sending message to AI:', error);
      updateStatus('Failed to get AI response');
      setTimeout(() => updateStatus(''), 3000);
    }
  }
  
  // Speak the AI response
  async function speakResponse(text) {
    if (useOpenAIVoice) {
      // Use OpenAI's TTS
      try {
        updateStatus('Getting voice response...');
        
        const response = await fetch('/api/tts', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ text })
        });
        
        if (!response.ok) {
          throw new Error('Failed to get voice response');
        }
        
        updateStatus('Speaking...');
        
        // Play the audio
        const audioBlob = await response.blob();
        const audioUrl = URL.createObjectURL(audioBlob);
        const audio = new Audio(audioUrl);
        
        audio.onended = () => {
          updateStatus('');
          URL.revokeObjectURL(audioUrl);
        };
        
        audio.play();
        
      } catch (error) {
        console.error('Error with TTS:', error);
        updateStatus('Error playing voice');
        setTimeout(() => updateStatus(''), 3000);
        
        // Fall back to browser TTS
        useBrowserTTS(text);
      }
    } else {
      // Use browser's built-in TTS
      useBrowserTTS(text);
    }
  }
  
  // Use browser's built-in TTS
  function useBrowserTTS(text) {
    if (!synth) {
      console.error('Browser does not support speech synthesis');
      return;
    }
    
    // Cancel any ongoing speech
    synth.cancel();
    
    updateStatus('Speaking...');
    
    const utterance = new SpeechSynthesisUtterance(text);
    
    // Pick a nice voice if available
    let voices = synth.getVoices();
    let selectedVoice = voices.find(voice => voice.name.includes('Google') && voice.name.includes('Female')) || 
                       voices.find(voice => voice.name.includes('Female')) || 
                       voices[0];
    if (selectedVoice) utterance.voice = selectedVoice;
    
    utterance.rate = 1.1;
    utterance.pitch = 1.0;
    
    utterance.onend = () => {
      updateStatus('');
    };
    
    synth.speak(utterance);
  }
  
  // Mock scanner for adding wines
  scanButton.addEventListener('click', () => {
    mockScanWine();
  });
  
  // Mock wine scanning
  function mockScanWine() {
    updateStatus('Scanning wine...');
    
    // Simulate scanning delay
    setTimeout(() => {
      const wineTypes = ['Red', 'White', 'Rosé', 'Sparkling'];
      const regions = ['Bordeaux', 'Tuscany', 'Napa Valley', 'Rioja', 'Mendoza'];
      const wineries = ['Château Lafite', 'Antinori', 'Robert Mondavi', 'Marqués de Riscal', 'Catena Zapata'];
      
      // Create mock wine data
      const mockWine = {
        id: `wine_${Date.now()}`,
        name: `${['Reserve', 'Estate', 'Grand Cru', 'Vintage'][Math.floor(Math.random() * 4)]} ${2010 + Math.floor(Math.random() * 12)}`,
        winery: wineries[Math.floor(Math.random() * wineries.length)],
        year: 2010 + Math.floor(Math.random() * 12),
        wineType: wineTypes[Math.floor(Math.random() * wineTypes.length)],
        region: regions[Math.floor(Math.random() * regions.length)],
        scanDate: new Date()
      };
      
      // Save to storage
      wineStorage.addWine(mockWine).then(() => {
        updateStatus('Wine added to collection!');
        setTimeout(() => updateStatus(''), 3000);
        
        // Reload wines
        loadWines();
        
        // AI message about the new wine
        const welcomeMessage = `I've added the ${mockWine.name} from ${mockWine.winery} to your collection. This is a ${mockWine.wineType} wine from ${mockWine.region}. Would you like to know more about it?`;
        addMessage(welcomeMessage, 'ai');
        speakResponse(welcomeMessage);
      });
    }, 1500);
  }
});