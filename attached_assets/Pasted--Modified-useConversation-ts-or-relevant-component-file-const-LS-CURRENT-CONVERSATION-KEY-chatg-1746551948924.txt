// Modified useConversation.ts or relevant component file
const LS_CURRENT_CONVERSATION_KEY = 'chatgpt_companion_current_conversation';

// Add to your existing state variables
const [isLoading, setIsLoading] = useState(true);

useEffect(() => {
  async function initializeConversation() {
    try {
      setIsLoading(true);
      
      // First try to get the last used conversation ID from localStorage
      const savedConversationId = localStorage.getItem(LS_CURRENT_CONVERSATION_KEY);
      
      if (savedConversationId) {
        // Verify this conversation still exists in the database
        try {
          const response = await apiRequest('GET', `/api/conversations/${savedConversationId}`);
          if (response.ok) {
            // Conversation exists, use it
            setCurrentConversationId(Number(savedConversationId));
            
            // Load messages for this conversation
            const messagesResponse = await apiRequest('GET', `/api/conversations/${savedConversationId}/messages`);
            if (messagesResponse.ok) {
              const messagesData = await messagesResponse.json();
              if (Array.isArray(messagesData)) {
                console.log(`Loaded ${messagesData.length} messages from saved conversation ID`);
                setMessages(messagesData);
              }
            }
            setIsLoading(false);
            return; // Exit early as we found and loaded the conversation
          }
        } catch (error) {
          console.warn('Saved conversation ID not found or invalid:', error);
          // Continue to fallback options below
        }
      }
      
      // If no valid saved conversation, check if we have conversations from API
      if (conversations && Array.isArray(conversations) && conversations.length > 0) {
        const mostRecentConversation = conversations[0]; // Assuming sorted by most recent
        const conversationId = mostRecentConversation.id;
        
        setCurrentConversationId(conversationId);
        localStorage.setItem(LS_CURRENT_CONVERSATION_KEY, String(conversationId));
        
        // Load messages for this conversation
        const messagesResponse = await apiRequest('GET', `/api/conversations/${conversationId}/messages`);
        if (messagesResponse.ok) {
          const messagesData = await messagesResponse.json();
          if (Array.isArray(messagesData)) {
            console.log(`Loaded ${messagesData.length} messages from most recent conversation`);
            setMessages(messagesData);
          }
        }
      } else {
        // If no conversations yet, create a new one
        console.log('No existing conversations found, creating new one');
        const response = await apiRequest('POST', '/api/conversations', { 
          title: 'New Conversation' 
        });
        const data = await response.json();
        setCurrentConversationId(data.id);
        localStorage.setItem(LS_CURRENT_CONVERSATION_KEY, String(data.id));
        setMessages([]);
      }
    } catch (error) {
      console.error('Failed to initialize conversation:', error);
    } finally {
      setIsLoading(false);
    }
  }

  // Only run initialization if conversations have been loaded from API
  // and we don't have a current conversation ID
  if (conversations !== null && currentConversationId === null) {
    initializeConversation();
  }
}, [conversations, currentConversationId]);

// When sending a message, update localStorage with current conversation ID
const handleSendMessage = async (content: string) => {
  // ... existing code ...
  
  // After sending message, ensure current conversation ID is saved
  if (currentConversationId) {
    localStorage.setItem(LS_CURRENT_CONVERSATION_KEY, String(currentConversationId));
  }
  
  // After processing the message, we reload from the database:
  const messagesResponse = await apiRequest('GET', `/api/conversations/${currentConversationId}/messages`);
  const messagesData = await messagesResponse.json();
  setMessages(messagesData);
  
  // ... rest of existing code ...
}