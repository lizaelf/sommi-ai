// ===== 1. Fix VoiceAssistant handleSuggestionClick =====

const handleSuggestionClick = (suggestion: string, pillId?: string, options?: { textOnly?: boolean; instantResponse?: string }) => {
  console.log("Suggestion clicked:", suggestion, "with options:", options);
  
  // Handle instant cached responses - bypass normal flow entirely
  if (options?.instantResponse) {
    console.log("VoiceAssistant: Instant cached response detected - setting playback states");
    
    // Set states for immediate voice playback
    setIsResponding(true);
    setShowUnmuteButton(false);
    setShowAskButton(false);
    setIsThinking(false);
    
    // Store the response text for potential unmute functionality
    (window as any).lastAssistantMessageText = options.instantResponse;
    
    console.log("VoiceAssistant: Ready for instant response playback");
    return; // Exit early - VoiceBottomSheet handles everything else
  }
  
  // For non-cached suggestions, use normal flow
  console.log("VoiceAssistant: No cached response, using normal API flow");
  onSendMessage(suggestion, pillId, options);
  setShowBottomSheet(false);
};

// ===== 2. Add event handler for cached response completion =====

useEffect(() => {
  // ... existing event handlers ...

  const handleCachedResponseEnded = () => {
    console.log("Cached response playback ended - resetting to Ask button");
    if (!isManuallyClosedRef.current) {
      setIsResponding(false);
      setShowUnmuteButton(false);
      setShowAskButton(true);
      setIsThinking(false);
    }
  };

  window.addEventListener('cachedResponseEnded', handleCachedResponseEnded);

  return () => {
    // ... existing cleanup ...
    window.removeEventListener('cachedResponseEnded', handleCachedResponseEnded);
  };
}, []);

// ===== 3. Fix VoiceBottomSheet suggestion click handler =====

onSuggestionClick={async (prompt, pillId, options) => {
  console.log("Voice bottom sheet suggestion clicked:", prompt);
  
  // Check cache immediately
  const suggestionId = prompt.toLowerCase().replace(/[^a-z0-9]+/g, '_');
  const currentWineKey = wineKey || 'default_wine';
  const cachedResponse = await suggestionCache.getCachedResponse(currentWineKey, suggestionId);
  
  if (cachedResponse) {
    console.log("Using cached response - playing immediately");
    
    // 1. Add messages to chat immediately
    const userMessage = {
      role: "user" as const,
      content: prompt,
      id: Date.now(),
      timestamp: new Date().toISOString(),
      conversationId: 0
    };
    
    window.dispatchEvent(new CustomEvent('immediateResponse', {
      detail: { message: userMessage, audio: null }
    }));
    
    setTimeout(() => {
      const assistantMessage = {
        role: "assistant" as const,
        content: cachedResponse,
        id: Date.now() + 1,
        timestamp: new Date().toISOString(),
        conversationId: 0
      };
      
      window.dispatchEvent(new CustomEvent('immediateResponse', {
        detail: { message: assistantMessage, audio: null }
      }));
    }, 100);
    
    // 2. Play TTS immediately
    if (typeof speechSynthesis !== 'undefined') {
      const utterance = new SpeechSynthesisUtterance(cachedResponse);
      
      // Use consistent male voice
      const voices = speechSynthesis.getVoices();
      const maleVoice = voices.find(voice => 
        voice.name.includes('Google UK English Male') ||
        voice.name.includes('Google US English Male') ||
        (voice.name.includes('Male') && voice.lang.startsWith('en'))
      ) || voices[0];
      
      if (maleVoice) utterance.voice = maleVoice;
      
      utterance.rate = 1.0;
      utterance.pitch = 1.0;
      utterance.volume = 1.0;
      
      speechSynthesis.cancel(); // Clear any existing speech
      
      utterance.onstart = () => {
        console.log("Cached TTS started");
      };
      
      utterance.onend = () => {
        console.log("Cached TTS ended");
        window.dispatchEvent(new CustomEvent('cachedResponseEnded'));
      };
      
      utterance.onerror = (error) => {
        console.error("Cached TTS error:", error);
        window.dispatchEvent(new CustomEvent('cachedResponseEnded'));
      };
      
      speechSynthesis.speak(utterance);
    }
    
    // 3. Notify VoiceAssistant about instant response
    if (onSuggestionClick) {
      onSuggestionClick(prompt, '', { instantResponse: cachedResponse });
    }
    
    return; // Don't proceed to normal flow
  }
  
  // No cache - use normal flow
  console.log("No cached response - using normal flow");
  if (onSuggestionClick) {
    onSuggestionClick(prompt);
  }
}}

// ===== 4. Summary of the fix =====

/*
The key changes:

1. VoiceAssistant.handleSuggestionClick now properly detects `options.instantResponse` 
   and sets the UI to "responding" state without calling the API

2. VoiceBottomSheet plays cached TTS immediately and adds messages via events,
   then notifies VoiceAssistant with the instantResponse flag

3. When cached TTS finishes, it fires 'cachedResponseEnded' event which 
   resets VoiceAssistant back to "Ask" button state

4. This bypasses all thinking states and unmute buttons for cached responses

Flow for cached suggestions:
Click → Check cache → Play TTS immediately → Set responding state → 
TTS ends → Reset to Ask button

Flow for non-cached suggestions:
Click → API call → Thinking state → Response → Unmute button → Ask button
*/